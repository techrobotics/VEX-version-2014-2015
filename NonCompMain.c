#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           lDrive,        tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port2,           lMainArm,      tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port3,           lSecArm,       tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port4,           clawPivot,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           claw,          tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port8,           rSecArm,       tmotorVex393, openLoop)
#pragma config(Motor,  port9,           rMainArm,      tmotorVex393, openLoop)
#pragma config(Motor,  port10,          rDrive,        tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Robot.h"
#include "Macros.h"
#include "Autonomous.c"
#include "UserControl.c"

task main()
{
	//INITIALIZATION
	mainArmSens = 0;
	secArmSens = 0;
	lDriveSens = 0;
	rDriveSens = 0;

	bool pivotIdle = false;

	//rightDrive((CIRCUMFERENCE));



	//USER CONTROL

	while (true)
	{
		drive(vexRT[Ch3], vexRT[Ch2]);


		//TEST:
		//AMOUNT OF EXTRA PER ROTATION
		//(USE MULTIPLE ROTATIONS)
		//SUBTRACT WHAT IS NEEDED
		//driveDistance(4 * PI);



		//LIMIT MAIN ARM SO SLOWER ABOVE 906

		//MAIN LIFT
		if (vexRT[Btn7U] > 0 && mainArmDegree < 140) {
			moveMainLift(MAIN_LIFT_UP_SPEED);
		}
		else if (vexRT[Btn7D] > 0) {
			moveMainLift(MAIN_LIFT_DOWN_SPEED);
		}
		else {
			moveMainLift(MAIN_LIFT_IDLE_SPEED);
		}


		//SECONDARY LIFT
		if (secArmDegree <= 85) {
			if (vexRT[Btn8U] > 0 ) {
				moveSecLift(SEC_LIFT_UP_SPEED);
			}
			else if (vexRT[Btn8D] > 0) {
				moveSecLift(SEC_LIFT_DOWN_SPEED);
			}
			else {
				moveSecLift(SEC_LIFT_IDLE_SPEED);
			}
		}

		else if (secArmDegree > 95) {
			if (vexRT[Btn8U] > 0) {
				moveSecLift(-SEC_LIFT_DOWN_SPEED);
			}
			else if (vexRT[Btn8D] > 0) {
				moveSecLift(-SEC_LIFT_UP_SPEED);
			}
			else {
				moveSecLift(-SEC_LIFT_IDLE_SPEED);
			}
		}
		else {
			moveSecLift(0);
		}


		/* if (vexRT[Btn8U] > 0) {
		if (secArmDegree <= 90){
		moveSecLift(SEC_LIFT_DOWN_SPEED);
		}
		}
		else if (vexRT[Btn8U] > 0) && {secArmDegree > 90)) {
		moveSecLift(-SEC_LIFT_DOWN_SPEED);
		}
		else if ((vexRT[Btn8D] > 0) && (secArmDegree <= 90)) {
		moveSecLift(SEC_LIFT_DOWN_SPEED);
		}
		else if ((vexRT[Btn8D] > 0) && (secArmDegree > 90)){
		moveSecLift(-SEC_LIFT_UP_SPEED);
		}
		else {
		if (secArmDegree > 90) {
		moveSecLift(-SEC_LIFT_IDLE_SPEED);
		}
		else if (secArmDegree < 90) {
		moveSecLift(SEC_LIFT_IDLE_SPEED);
		}
		else {
		moveSecLift(0);

		}
		}

		*/
		//OLD SEC_LIFT FOR BACKUP

		/*
		if (vexRT[Btn8U] > 0) {
		moveSecLift(TEST_SPEED);
		}
		else if (vexRT[Btn8D] > 0) {
		moveSecLift(LIFT_DOWN_SPEED);
		}
		else {
		moveSecLift(SEC_LIFT_IDLE_SPEED);
		}
		*/


		//CLAW
		if (vexRT[Btn6U] > 0) {
			clampClaw(CLAW_CLAMP_SPEED);
		}
		else if (vexRT[Btn6D] > 0) {
			clampClaw(-CLAW_CLAMP_SPEED);
		}
		else {
			clampClaw(0);
		}

		if (vexRT[Btn7L] > 0) {
			if (!pivotIdle) {
				pivotIdle = true;
			}

			else if (pivotIdle) {
				pivotIdle = false;
			}
		}

		//CLAW PIVOT
		if (vexRT[Btn8R] > 0) {
			pivotClaw(CLAW_PIVOT_SPEED);
		}
		else if (vexRT[Btn8L] > 0) {
			pivotClaw(-CLAW_PIVOT_SPEED);
		}
		else {
			if (pivotIdle) {
				pivotClaw(CLAW_PIVOT_IDLE_SPEED);
			}
			else {
				pivotClaw(0);
			}
		}
	}


}
